<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI å¯©å•éŠæˆ²</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            overscroll-behavior-y: contain;
        }
        .card {
            background-color: #2d3748;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .dialogue-area {
            flex-grow: 1;
            overflow-y: auto;
            border: 1px solid #4a5568;
            padding: 10px;
            border-radius: 8px;
            background-color: #1f2937;
            min-height: 200px;
        }
        .dialogue-bubble {
            padding: 8px 12px;
            border-radius: 15px;
            margin-bottom: 8px;
            max-width: 85%;
            word-wrap: break-word;
        }
        .player-bubble {
            background-color: #4299e1;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        .ai-bubble {
            background-color: #4a5568;
            color: #e2e8f0;
            margin-right: auto;
        }
        .keyword {
            text-decoration: underline;
            color: #63b3ed;
            cursor: pointer;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 16px;
        }
        .modal-content {
            background-color: #2d3748;
            padding: 20px;
            border-radius: 8px;
            width: 100%;
            max-width: 500px; /* Default max-width */
            max-height: 90vh; /* Increased max-height slightly */
            overflow-y: auto;
            text-align: left;
            color: #e2e8f0;
        }
        .modal-content.modal-lg { /* For larger modal like Case Summary */
            max-width: 600px;
        }
        .modal-content h3 {
            text-align: center;
            margin-bottom: 16px;
        }
        .story-summary-text {
            font-size: 0.8rem; /* Smaller text for story summary */
        }
        .story-summary-divider {
            border-top: 1px solid #4a5568;
            margin: 12px 0;
        }
        .personality-block {
            background-color: #374151; /* Slightly different background */
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            border: 1px solid #4a5568;
        }
        .tone-button {
            background-color: #4a5568;
            color: #e2e8f0;
            border: 1px solid #718096;
            flex-grow: 1;
            padding: 8px 0;
        }
        .tone-button.active {
            background-color: #3182ce;
            color: white;
            border-color: #3182ce;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .game-main-area {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 20px); /* Adjusted for padding */
            padding: 8px;
        }
    </style>
</head>
<body class="overscroll-y-contain">
    <div class="game-main-area container mx-auto">
        <header class="text-center mb-3">
            <h1 class="text-2xl sm:text-3xl font-bold text-blue-400">AI å¯©å•éŠæˆ²</h1>
            <div class="flex justify-around text-sm sm:text-base mt-1">
                <p>ğŸŸ¢ å›åˆæ•¸: <span id="round-count">0</span></p>
                <p>ğŸ—£ï¸ é ‘æŠ—åº¦: <span id="confession-meter-text">æ…‹åº¦å¼·ç¡¬</span></p>
            </div>
            <p class="text-xs mt-1" title="é€™æ˜¯ Firebase åŒ¿åèªè­‰ç‚ºæ‚¨çš„éŠæˆ²æœƒè©±ç”Ÿæˆçš„å”¯ä¸€æ¨™è­˜ï¼Œç”¨æ–¼ä¿å­˜éŠæˆ²é€²åº¦ã€‚">æ‚¨çš„ User ID: <span id="user-id-display">è¼‰å…¥ä¸­...</span></p>
        </header>

        <div class="flex gap-3 mb-3">
            <div id="avatar" class="w-20 h-20 sm:w-24 sm:h-24 bg-gray-600 rounded-full flex-shrink-0 flex items-center justify-center text-gray-400 text-xs sm:text-sm p-1 text-center">
                é ­åƒé ç•™
            </div>
            <div class="flex-grow flex flex-col gap-2 card p-2 text-xs sm:text-sm">
                 <h2 class="text-sm sm:text-base font-semibold mb-1 text-blue-300 text-center">å«ŒçŠ¯ç‹€æ…‹</h2>
                 <div id="suspect-status" class="grid grid-cols-2 gap-x-2 gap-y-1">
                    <p>ğŸ“ˆ<strong>å¿ƒç‡:</strong> <span id="heart-rate">75</span> bpm</p>
                    <p>ğŸ©¸<strong>è¡€å£“:</strong> <span id="blood-pressure">120/80</span></p>
                    <p>ğŸ˜ <strong>è¡¨æƒ…:</strong> <span id="facial-expression" class="italic">è®€å–ä¸­...</span></p>
                    <p>ğŸ§<strong>è‚¢é«”:</strong> <span id="body-language" class="italic">è®€å–ä¸­...</span></p>
                    <p>ğŸ¤<strong>å¾®å‹•ä½œ:</strong> <span id="micro-action" class="italic">è®€å–ä¸­...</span></p>
                    <p>ğŸ—£ï¸<strong>èªæ°£:</strong> <span id="voice-tone" class="italic">è®€å–ä¸­...</span></p>
                </div>
            </div>
        </div>
        
        <div class="grid grid-cols-2 gap-3 mb-3">
            <button id="show-personal-details-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-3 rounded-md text-sm sm:text-base">ğŸ‘¤ å€‹äººè³‡æ–™</button>
            <button id="show-story-summary-button" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white py-2 px-3 rounded-md text-sm sm:text-base">ğŸ“œ æ¡ˆä»¶æ¦‚è¦</button>
        </div>


        <div id="dialogue-area" class="dialogue-area mb-3">
            <div class="ai-bubble">ä½ å¥½ï¼Œè­¦å®˜ã€‚æœ‰ä»€éº¼äº‹å—ï¼Ÿ</div>
        </div>

        <div class="mt-auto">
            <textarea id="player-input" class="w-full p-2 border border-gray-600 rounded-md bg-gray-700 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-sm sm:text-base" rows="2" placeholder="è¼¸å…¥æ‚¨çš„å•é¡Œ..."></textarea>
            <div class="mt-2 flex gap-1 sm:gap-2">
                <button class="tone-button active rounded-md text-xs sm:text-sm" data-tone="å¹³ç·©">ğŸ˜Œ å¹³ç·©</button>
                <button class="tone-button rounded-md ml-1 text-xs sm:text-sm" data-tone="æ†¤æ€’">ğŸ˜¡ æ†¤æ€’</button>
                <button class="tone-button rounded-md ml-1 text-xs sm:text-sm" data-tone="æŒ‘é‡">ğŸ˜ æŒ‘é‡</button>
            </div>
             <button id="send-button" class="mt-2 w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150 text-sm sm:text-base">
                ç™¼é€
            </button>
        </div>
    </div>

    <div id="personal-details-modal" class="modal hidden">
        <div class="modal-content">
            <h3 class="text-xl font-bold text-blue-300">ğŸ‘¤ å«ŒçŠ¯å€‹äººè³‡æ–™</h3>
            <div id="modal-personal-details-content">
                <p><strong>å§“å:</strong> <span id="suspect-name-modal">ææ˜</span></p>
                <p><strong>å‡ºç”Ÿå¹´æœˆæ—¥:</strong> <span id="dob-modal">è®€å–ä¸­...</span></p>
                <p><strong>æ˜Ÿåº§:</strong> <span id="zodiac-modal">è®€å–ä¸­...</span></p>
                <p><strong>è¡€å‹:</strong> <span id="blood-type-modal">è®€å–ä¸­...</span></p>
                <p><strong>å¹´ç´€:</strong> <span id="age-modal">è®€å–ä¸­...</span></p>
                <p><strong>æ€§åˆ¥:</strong> <span id="gender-modal">è®€å–ä¸­...</span></p>
                <div class="personality-block">
                    <p class="font-semibold mb-1">ğŸ­ å€‹æ€§æ¦‚è¿°:</p>
                    <p id="personality-modal" class="italic text-sm">è®€å–ä¸­...</p>
                </div>
            </div>
            <button onclick="document.getElementById('personal-details-modal').classList.add('hidden')" class="mt-6 w-full bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-md">é—œé–‰</button>
        </div>
    </div>

    <div id="story-summary-modal" class="modal hidden">
        <div class="modal-content modal-lg"> <h3 class="text-xl font-bold text-blue-300">ğŸ“œ æ¡ˆä»¶æ¦‚è¦</h3>
            <div id="modal-story-summary-content" class="story-summary-text">
                <div>
                    <p class="font-semibold">è¢«å®³äººé©—å±å ±å‘Š:</p>
                    <span id="autopsy-report-modal"></span>
                </div>
                <hr class="story-summary-divider">
                <div>
                    <p class="font-semibold mt-2">å°å«ŒçŠ¯ä¸åˆ©çš„ç›®å‰è­‰æ“š:</p>
                    <ul id="evidence-list-modal" class="list-disc list-inside ml-4"></ul>
                </div>
                <hr class="story-summary-divider">
                <div>
                    <p class="font-semibold mt-2">å«ŒçŠ¯èª¿æŸ¥ç–‘é»:</p>
                    <ul id="doubts-list-modal" class="list-disc list-inside ml-4"></ul>
                </div>
            </div>
            <button onclick="document.getElementById('story-summary-modal').classList.add('hidden')" class="mt-6 w-full bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-md">é—œé–‰</button>
        </div>
    </div>

    <div id="keyword-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="keyword-modal-title" class="text-xl font-bold text-blue-300">ğŸ”‘ é—œéµå­—è£œå……</h3>
            <p id="keyword-modal-text">è£œå……å…§å®¹...</p>
            <div id="keyword-loading-spinner" class="loading-spinner my-4 hidden"></div>
            <button onclick="document.getElementById('keyword-modal').classList.add('hidden')" class="mt-6 w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md">é—œé–‰</button>
        </div>
    </div>

    <div id="game-over-modal" class="modal hidden">
        <div class="modal-content text-center">
            <h3 id="game-over-title" class="text-2xl font-bold mb-4">âš–ï¸ å¯©å•çµæŸ</h3>
            <p id="game-over-text">AI å·²èªç½ªï¼</p>
            <p>æ‚¨ç¸½å…±èŠ±äº† <span id="total-rounds">0</span> å›åˆã€‚</p>
            <button id="restart-game-button" class="mt-6 bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-md">ğŸ”„ é‡æ–°é–‹å§‹</button>
        </div>
    </div>
    
    <div id="ai-thinking-modal" class="modal hidden">
        <div class="modal-content text-center">
            <p class="text-lg">ğŸ¤– AI æ­£åœ¨æ€è€ƒå›æ‡‰...</p>
            <div class="loading-spinner my-4"></div>
        </div>
    </div>

    <script type="module">
        // Firebase SDK imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, collection, serverTimestamp, onSnapshot, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // DOM Elements
        const roundCountEl = document.getElementById('round-count');
        const confessionMeterTextEl = document.getElementById('confession-meter-text');
        
        // Suspect Status on main screen
        const heartRateEl = document.getElementById('heart-rate');
        const bloodPressureEl = document.getElementById('blood-pressure');
        const facialExpressionEl = document.getElementById('facial-expression');
        const bodyLanguageEl = document.getElementById('body-language');
        const microActionEl = document.getElementById('micro-action');
        const voiceToneEl = document.getElementById('voice-tone');


        // Modal content for Personal Details
        const suspectNameModalEl = document.getElementById('suspect-name-modal');
        const dobModalEl = document.getElementById('dob-modal');
        const zodiacModalEl = document.getElementById('zodiac-modal');
        const bloodTypeModalEl = document.getElementById('blood-type-modal');
        const ageModalEl = document.getElementById('age-modal');
        const genderModalEl = document.getElementById('gender-modal');
        const personalityModalEl = document.getElementById('personality-modal');

        // Modal content for Story Summary
        const autopsyReportModalEl = document.getElementById('autopsy-report-modal');
        const evidenceListModalEl = document.getElementById('evidence-list-modal');
        const doubtsListModalEl = document.getElementById('doubts-list-modal');

        const showPersonalDetailsButton = document.getElementById('show-personal-details-button');
        const showStorySummaryButton = document.getElementById('show-story-summary-button');
        const personalDetailsModal = document.getElementById('personal-details-modal');
        const storySummaryModal = document.getElementById('story-summary-modal');

        const dialogueAreaEl = document.getElementById('dialogue-area');
        const playerInputEl = document.getElementById('player-input');
        const sendButton = document.getElementById('send-button');
        const toneButtons = document.querySelectorAll('.tone-button');
        const userIdDisplayEl = document.getElementById('user-id-display');

        const keywordModal = document.getElementById('keyword-modal');
        const keywordModalTitle = document.getElementById('keyword-modal-title');
        const keywordModalText = document.getElementById('keyword-modal-text');
        const keywordLoadingSpinner = document.getElementById('keyword-loading-spinner');

        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverTitle = document.getElementById('game-over-title');
        const gameOverText = document.getElementById('game-over-text');
        const totalRoundsEl = document.getElementById('total-rounds');
        const restartGameButton = document.getElementById('restart-game-button');
        const aiThinkingModal = document.getElementById('ai-thinking-modal');

        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "YOUR_API_KEY", authDomain: "YOUR_AUTH_DOMAIN", projectId: "YOUR_PROJECT_ID" };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        setLogLevel('error'); // Changed from debug to error to reduce console noise

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'interrogation-game-default';
        let userId = null;
        let gameId = `game_${Date.now()}`; 
        let gameStateUnsubscribe = null; 

        let gameState = {
            round: 0,
            confessionMeter: 100, // Internal percentage
            suspect: {
                name: "ææ˜", 
                dob: "", zodiac: "", bloodType: "", age: 0, gender: "",
                personality: "è®€å–ä¸­...",
                heartRate: 75, bloodPressure: "120/80", 
                // New observable traits
                facialExpression: "è®€å–ä¸­...",
                bodyLanguage: "è®€å–ä¸­...", // Moved from physiological, now part of observable state
                microAction: "è®€å–ä¸­...",
                voiceTone: "è®€å–ä¸­..."
            },
            caseDetails: {
                autopsyReport: "è¢«å®³è€…ç‹å°è¯ï¼Œå¥³æ€§ï¼Œ35æ­²ï¼Œæ­»æ–¼é ­éƒ¨é­éˆå™¨é‡æ“Šï¼Œé€ æˆé¡±éª¨ç²‰ç¢æ€§éª¨æŠ˜ã€‚æ­»äº¡æ™‚é–“æ¨æ–·ç‚ºæ˜¨æ™š10é»è‡³å‡Œæ™¨1é»ä¹‹é–“ã€‚ç¾å ´ç„¡æ˜é¡¯æ‰“é¬¥ç—•è·¡ï¼Œä½†æœ‰å°‘é‡æ™æ‰è·¡è±¡ã€‚",
                evidence: [
                    { text: "åœ¨è¢«å®³è€…å®¶ä¸­ç™¼ç¾ä¸€æšä¸å±¬æ–¼è¢«å®³è€…çš„<span class='keyword' data-keyword='æŒ‡ç´‹'>æŒ‡ç´‹</span>ï¼Œåˆæ­¥æ¯”å°èˆ‡å«ŒçŠ¯éƒ¨åˆ†å»åˆã€‚", id: "ev1"},
                    { text: "æœ‰ç›®æ“Šè€…è²ç¨±åœ¨æ¡ˆç™¼ç•¶æ™šçœ‹è¦‹èˆ‡å«ŒçŠ¯é«”å‹ç›¸ä¼¼çš„äººåœ¨è¢«å®³è€…å…¬å¯“é™„è¿‘å¾˜å¾Šã€‚", id: "ev2"}
                ],
                doubts: [
                    { text: "å«ŒçŠ¯è²ç¨±æ¡ˆç™¼æ™‚ç¨è‡ªåœ¨å®¶çœ‹é›»å½±ï¼Œä½†ç„¡æ³•æä¾›å…·é«”é›»å½±åç¨±æˆ–å…§å®¹ã€‚", id: "db1"},
                    { text: "å«ŒçŠ¯èˆ‡è¢«å®³è€…æ›¾æœ‰å•†æ¥­ç³¾ç´›ï¼Œæ¶‰åŠä¸€ç­†é‡‘é¡ä¸å°çš„æ¬¾é …ã€‚", id: "db2"}
                ]
            },
            dialogueHistory: [{ speaker: "AI", text: "ä½ å¥½ï¼Œè­¦å®˜ã€‚æœ‰ä»€éº¼äº‹å—ï¼Ÿ" }],
            selectedTone: "å¹³ç·©",
            gameOver: false
        };
        
        // Function to get text description for confession meter
        function getConfessionMeterText(percentage) {
            if (percentage > 80) return "æ…‹åº¦å¼·ç¡¬";
            if (percentage > 60) return "æ•…ä½œé®å®š";
            if (percentage > 40) return "ç•¥é¡¯å‹•æ–";
            if (percentage > 20) return "å¿ƒè™›æ…Œäº‚";
            if (percentage > 0) return "ç€•è‡¨å´©æ½°";
            return "å·²ç„¶èªç½ª";
        }

        // Firebase Authentication and Data Handling
        async function initializeGame() {
             try {
                await setPersistence(auth, browserLocalPersistence);
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication error:", error);
                if (error.code === 'auth/invalid-custom-token' || !auth.currentUser) {
                    try { await signInAnonymously(auth); } catch (anonError) {
                        console.error("Anonymous sign-in failed:", anonError);
                        userIdDisplayEl.textContent = "èªè­‰å¤±æ•—"; return;
                    }
                }
            }

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    userIdDisplayEl.textContent = userId.substring(0,8) + "..."; // Shorten displayed ID for brevity
                } else {
                    userId = `anon_${crypto.randomUUID()}`;
                    userIdDisplayEl.textContent = "åŒ¿åè¨ªå®¢";
                }
                await loadOrCreateGameState();
            });
        }
        
        async function getGameDocRef() {
            if (!userId) {
                const tempGameId = `local_game_${Date.now()}`;
                return doc(db, "localGames", tempGameId);
            }
            return doc(db, "artifacts", appId, "users", userId, "interrogationGames", gameId);
        }

        async function loadOrCreateGameState() {
            if (!userId) {
                updateUI(gameState); // Use local state if no user
                await generateInitialSuspectDetailsAndState(); // Generate all initial data
                return;
            }
            const gameDocRef = await getGameDocRef();
            if (gameStateUnsubscribe) gameStateUnsubscribe(); // Unsubscribe from previous listener

            try {
                const docSnap = await getDoc(gameDocRef);
                if (docSnap.exists()) {
                    console.log("Loading existing game state from Firestore for gameId:", gameId);
                    gameState = { ...gameState, ...docSnap.data() }; // Merge, prioritizing Firestore data
                     // Ensure all suspect fields, especially new ones, are present
                    if (!gameState.suspect || !gameState.suspect.dob || !gameState.suspect.facialExpression) {
                        console.log("Suspect details incomplete, regenerating...");
                        await generateInitialSuspectDetailsAndState(); // Regenerate if core or new fields missing
                    }
                } else {
                    console.log("No existing game state found for gameId:", gameId, ". Creating new game state in Firestore.");
                    await generateInitialSuspectDetailsAndState(); // Generate all initial data before saving
                    await setDoc(gameDocRef, { ...gameState, createdAt: serverTimestamp(), lastUpdatedAt: serverTimestamp() });
                }
            } catch (error) {
                console.error("Error loading/creating game state from Firestore:", error);
                // If Firestore fails, use local default state to allow gameplay
                console.warn("Using local game state due to Firestore error.");
                await generateInitialSuspectDetailsAndState();
            }
            
            updateUI(gameState);

            // Set up a real-time listener for game state changes
            gameStateUnsubscribe = onSnapshot(gameDocRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    console.log("Game state updated from Firestore:", docSnapshot.data());
                    gameState = { ...gameState, ...docSnapshot.data() };
                     if (!gameState.suspect || !gameState.suspect.dob || !gameState.suspect.facialExpression) {
                        generateInitialSuspectDetailsAndState().then(() => updateUI(gameState));
                    } else {
                        updateUI(gameState);
                    }
                } else {
                    console.log("Game document deleted or does not exist for gameId:", gameId);
                }
            }, (error) => {
                console.error("Error in onSnapshot listener:", error);
            });
        }

        async function saveGameState() {
            if (!userId) {
                console.warn("User ID not available, cannot save game state to Firestore.");
                return; 
            }
            const gameDocRef = await getGameDocRef();
            if (!gameDocRef) return;

            try {
                await setDoc(gameDocRef, { ...gameState, lastUpdatedAt: serverTimestamp() }, { merge: true });
                console.log("Game state saved to Firestore for gameId:", gameId);
            } catch (error) {
                console.error("Error saving game state to Firestore:", error);
            }
        }
        
        // --- DeepSeek API Interaction ---
        const DEEPSEEK_API_KEY = "sk-19179bb0c0c94acaa53ca82dc1d28bbf"; 
        const DEEPSEEK_API_URL = "https://api.deepseek.com/chat/completions";

        async function callDeepSeekAPI(systemPrompt, userPrompt, forMultipleFields = false) {
            aiThinkingModal.classList.remove('hidden');
            const payload = {
                model: "deepseek-chat", 
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt }
                ],
                stream: false,
                // temperature: 0.7 // Optional: Adjust for creativity if needed
            };

            try {
                const response = await fetch(DEEPSEEK_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${DEEPSEEK_API_KEY}`
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    console.error("DeepSeek API Error Response:", errorBody);
                    throw new Error(`DeepSeek API request failed with status ${response.status}: ${errorBody}`);
                }

                const result = await response.json();
                aiThinkingModal.classList.add('hidden');

                if (result.choices && result.choices.length > 0 && result.choices[0].message && result.choices[0].message.content) {
                    return result.choices[0].message.content;
                } else {
                    console.error("Unexpected DeepSeek API response structure:", result);
                    throw new Error("Unexpected API response structure from DeepSeek.");
                }
            } catch (error) {
                console.error("Error calling DeepSeek API:", error);
                aiThinkingModal.classList.add('hidden');
                // Return a specific structure for multiple fields if an error occurs, or a string for single field
                return forMultipleFields ? { error: error.message } : `AI (DeepSeek) ç„¡æ³•å›æ‡‰ (${error.message.substring(0,30)}...)`;
            }
        }

        // Combined function to generate initial suspect details and their observable state
        async function generateInitialSuspectDetailsAndState() {
            // Generate basic details first
            const genders = ["ç”·æ€§", "å¥³æ€§"];
            gameState.suspect.gender = genders[Math.floor(Math.random() * genders.length)];
            const dobTimestamp = Date.now() - Math.floor(Math.random() * 20 + 20) * 365 * 24 * 60 * 60 * 1000; // Age 20-40
            const birthDate = new Date(dobTimestamp);
            const year = birthDate.getFullYear();
            const month = birthDate.getMonth() + 1;
            const day = birthDate.getDate();
            gameState.suspect.dob = `${year}å¹´${month}æœˆ${day}æ—¥`;
            gameState.suspect.age = new Date().getFullYear() - year;
            gameState.suspect.zodiac = getZodiacSign(day, month);
            gameState.suspect.bloodType = ["A", "B", "AB", "O"][Math.floor(Math.random() * 4)] + "å‹";
            // Initialize physiological data with some randomness
            gameState.suspect.heartRate = 70 + Math.floor(Math.random() * 10) -5; // e.g., 65-75
            gameState.suspect.bloodPressure = `${115 + Math.floor(Math.random() * 10) -5}/${75 + Math.floor(Math.random()*10)-5}`; // e.g. 110/70 to 120/80


            const systemPersonalityPrompt = "ä½ æ˜¯ä¸€ä½éŠæˆ²NPCè¨­è¨ˆå¸«ã€‚";
            const userPersonalityPrompt = `è«‹ç‚ºä»¥ä¸‹èƒŒæ™¯çš„å¯©å•éŠæˆ²å«ŒçŠ¯ç”Ÿæˆä¸€æ®µç°¡çŸ­çš„å€‹æ€§æè¿°ï¼ˆç´„20-30å­—ï¼‰ï¼š
            æ€§åˆ¥ï¼š${gameState.suspect.gender}ï¼Œæ˜Ÿåº§ï¼š${gameState.suspect.zodiac}ï¼Œè¡€å‹ï¼š${gameState.suspect.bloodType}ï¼Œå¹´é½¡ï¼š${gameState.suspect.age}æ­²ã€‚
            å€‹æ€§æè¿°æ‡‰ç°¡æ½”ï¼Œä¸¦æš—ç¤ºå…¶åœ¨å¯©å•ä¸­å¯èƒ½çš„è¡Œç‚ºæ¨¡å¼ã€‚`;
            
            const personalityResponse = await callDeepSeekAPI(systemPersonalityPrompt, userPersonalityPrompt);
            gameState.suspect.personality = (personalityResponse && !personalityResponse.startsWith("AI (DeepSeek) ç„¡æ³•å›æ‡‰")) ? personalityResponse : "é›£ä»¥æ‰æ‘¸ï¼Œä¼¼ä¹éš±è—è‘—ä»€éº¼ã€‚";

            // Then generate initial observable state (can be simpler for initial state)
            const initialObservables = await generateSuspectObservableState("éŠæˆ²å‰›é–‹å§‹ï¼Œåµè¨Šå®¤æ°£æ°›åš´è‚…ã€‚"); // Pass a neutral context
            gameState.suspect.facialExpression = initialObservables.facialExpression || "é¢ç„¡è¡¨æƒ…";
            gameState.suspect.bodyLanguage = initialObservables.bodyLanguage || "é›™æ‰‹æ”¾åœ¨æ¡Œä¸Š";
            gameState.suspect.microAction = initialObservables.microAction || "å¶çˆ¾çœ¨çœ¼";
            gameState.suspect.voiceTone = initialObservables.voiceTone || "èªæ°£å¹³éœ";
        }

        function getZodiacSign(day, month) { 
            const zodiacSigns = [
                { sign: "æ‘©ç¾¯åº§", start: [12, 22], end: [1, 19] }, { sign: "æ°´ç“¶åº§", start: [1, 20], end: [2, 18] },
                { sign: "é›™é­šåº§", start: [2, 19], end: [3, 20] }, { sign: "ç™½ç¾Šåº§", start: [3, 21], end: [4, 19] },
                { sign: "é‡‘ç‰›åº§", start: [4, 20], end: [5, 20] }, { sign: "é›™å­åº§", start: [5, 21], end: [6, 21] },
                { sign: "å·¨èŸ¹åº§", start: [6, 22], end: [7, 22] }, { sign: "ç…å­åº§", start: [7, 23], end: [8, 22] },
                { sign: "è™•å¥³åº§", start: [8, 23], end: [9, 22] }, { sign: "å¤©ç§¤åº§", start: [9, 23], end: [10, 23] },
                { sign: "å¤©è åº§", start: [10, 24], end: [11, 22] }, { sign: "å°„æ‰‹åº§", start: [11, 23], end: [12, 21] }
            ];
            for (const z of zodiacSigns) {
                if ((month === z.start[0] && day >= z.start[1]) || (month === z.end[0] && day <= z.end[1])) {
                    return z.sign;
                }
            }
            return "æœªçŸ¥";
        }

        // Function to get AI's dialogue response
        async function getAIResponse(playerMessage) {
            const evidenceText = gameState.caseDetails.evidence.map(e => e.text.replace(/<[^>]*>/g, "")).join("ï¼›");
            const doubtsText = gameState.caseDetails.doubts.map(d => d.text.replace(/<[^>]*>/g, "")).join("ï¼›");

            const systemPrompt = `ä½ æ˜¯è¬€æ®ºæ¡ˆå«ŒçŠ¯ ${gameState.suspect.name} (å€‹æ€§: ${gameState.suspect.personality})ã€‚
            ä½ ç›®å‰çš„é ‘æŠ—åº¦è¢«æè¿°ç‚ºã€Œ${getConfessionMeterText(gameState.confessionMeter)}ã€ã€‚
            ç”Ÿç†ç‹€æ…‹ï¼šå¿ƒç‡ ${gameState.suspect.heartRate} bpmï¼Œè¡€å£“ ${gameState.suspect.bloodPressure}ã€‚
            å¤–åœ¨è¡¨ç¾ï¼šè¡¨æƒ… ${gameState.suspect.facialExpression}ï¼Œè‚¢é«” ${gameState.suspect.bodyLanguage}ï¼Œå¾®å‹•ä½œ ${gameState.suspect.microAction}ï¼Œèªæ°£ ${gameState.suspect.voiceTone}ã€‚
            ä½ çš„ç›®æ¨™æ˜¯ç›¡å¯èƒ½ä¸èªç½ªï¼Œä½†å›ç­”è¦ç¬¦åˆä½ çš„å€‹æ€§å’Œç•¶å‰æƒ…å¢ƒã€‚
            å¦‚æœä½ çš„æƒ…ç·’è®Šå¾—æ¿€å‹•ã€æ…Œäº‚æˆ–è©¦åœ–èƒ¡è¨€äº‚èªï¼Œä½ å¯ä»¥ç”¨å¤šå€‹ç°¡çŸ­çš„å°è©±æ¡†ä¾†å›æ‡‰ï¼ˆç”¨ "||" åˆ†éš”æ¯å€‹å°è©±æ¡†çš„å…§å®¹ï¼‰ã€‚
            å›ç­”æ™‚ï¼Œå¦‚æœæåˆ°æ¡ˆä»¶ç›¸é—œçš„é—œéµç‰©å“æˆ–åœ°é»ï¼ˆä¾‹å¦‚ï¼šæ§Œå­ã€å…¬å¯“ã€å…¬åœ’ã€åˆ€æ¢°ã€è¢«å®³è€…å§“åã€ç‰¹å®šæ™‚é–“é»ï¼‰ï¼Œè«‹åœ¨è©²è©å½™å‰å¾ŒåŠ ä¸Š @@ï¼Œä¾‹å¦‚ @@æ§Œå­@@ã€‚
            ä½ çš„å›ç­”æ‡‰è©²ç°¡æ½”æœ‰åŠ›ã€‚`;
            const userPrompt = `ç›®å‰å°ä½ ä¸åˆ©çš„è­‰æ“šæœ‰ï¼š${evidenceText}ã€‚èª¿æŸ¥äººå“¡å°ä½ çš„ç–‘é»æ˜¯ï¼š${doubtsText}ã€‚å¯©å•è€…ï¼ˆç©å®¶ï¼‰ç”¨ã€Œ${gameState.selectedTone}ã€çš„èªæ°£å•ä½ ï¼šã€Œ${playerMessage}ã€`;

            const response = await callDeepSeekAPI(systemPrompt, userPrompt);
            if (response && !response.startsWith("AI (DeepSeek) ç„¡æ³•å›æ‡‰")) {
                return response.split("||").map(r => r.trim());
            }
            return ["æˆ‘ä¸çŸ¥é“ä½ åœ¨èªªä»€éº¼ã€‚"]; // Fallback
        }

        // Function to get keyword information
        async function getKeywordInfo(keyword) {
            keywordLoadingSpinner.classList.remove('hidden');
            keywordModalText.textContent = ""; 

            const systemPrompt = "ä½ æ˜¯ä¸€ä½åµæ¢åŠ©æ‰‹ï¼Œæä¾›æ¡ˆä»¶ç·šç´¢ã€‚";
            const userPrompt = `åœ¨ä¸€å€‹è¬€æ®ºæ¡ˆçš„å¯©å•æƒ…å¢ƒä¸­ï¼Œæåˆ°äº†é—œéµå­—ã€Œ${keyword}ã€ã€‚è«‹é‡å°é€™å€‹é—œéµå­—ï¼Œæä¾›ä¸€æ®µç°¡çŸ­ï¼ˆç´„30-50å­—ï¼‰çš„è£œå……è³‡è¨Šæˆ–ç·šç´¢ï¼Œé€™æ®µè³‡è¨Šæ‡‰è©²å°ç©å®¶ï¼ˆå¯©å•è€…ï¼‰æœ‰æ‰€å¹«åŠ©ã€‚ä¾‹å¦‚ï¼Œå¦‚æœé—œéµå­—æ˜¯ã€Œæ§Œå­ã€ï¼Œä½ å¯ä»¥èªªï¼šã€Œè­¦æ–¹åœ¨æ¡ˆç™¼ç¾å ´æ‰¾åˆ°ä¸€æŠŠå¸¶æœ‰è¡€è·¡çš„æ§Œå­ï¼Œä¸Šé¢åŒæ™‚æœ‰è¢«å®³è€…çš„DNAå’Œä¸€æšæ¨¡ç³Šçš„æŒ‡ç´‹ï¼Œæ­£åœ¨é€²è¡Œæ¯”å°ã€‚ã€å¦‚æœé—œéµå­—æ˜¯ã€Œå…¬åœ’ã€ï¼Œä½ å¯ä»¥èªªï¼šã€Œæ ¹æ“šé€šè¨Šè¨˜éŒ„ï¼Œè¢«å®³è€…æ‰‹æ©Ÿæœ€å¾Œçš„è¨Šè™Ÿä½ç½®æ˜¯åœ¨åŸå¸‚ä¸­å¤®å…¬åœ’é™„è¿‘ã€‚ã€è«‹ç›´æ¥çµ¦å‡ºè£œå……è³‡è¨Šï¼Œä¸è¦æœ‰é¡å¤–çš„é–‹é ­æˆ–çµå°¾ã€‚`;
            
            const info = await callDeepSeekAPI(systemPrompt, userPrompt);
            keywordLoadingSpinner.classList.add('hidden');
            if (info && !info.startsWith("AI (DeepSeek) ç„¡æ³•å›æ‡‰")) {
                keywordModalText.textContent = info;
            } else {
                keywordModalText.textContent = `é—œæ–¼ã€Œ${keyword}ã€çš„æ›´å¤šè³‡è¨Šç›®å‰ç„¡æ³•å–å¾—ã€‚`;
            }
        }
        
        // Function to generate suspect's observable state (facial expression, body language, etc.)
        async function generateSuspectObservableState(lastAIMessage = "") {
            const systemPrompt = "ä½ æ˜¯çŠ¯ç½ªå¿ƒç†å´å¯«å¸«ã€‚æ ¹æ“šæä¾›çš„å«ŒçŠ¯è³‡æ–™å’Œæœ€è¿‘çš„å°è©±ï¼Œç”Ÿæˆä¸€å€‹JSONæ ¼å¼çš„å°è±¡ï¼Œæè¿°å«ŒçŠ¯ç•¶å‰çš„å¤–åœ¨è¡¨ç¾ã€‚";
            const userPrompt = `å«ŒçŠ¯ ${gameState.suspect.name} (å€‹æ€§: ${gameState.suspect.personality})ã€‚
            ç›®å‰å¿ƒç‡: ${gameState.suspect.heartRate} bpmï¼Œè¡€å£“: ${gameState.suspect.bloodPressure} mmHgã€‚
            é ‘æŠ—åº¦æè¿°ç‚ºã€Œ${getConfessionMeterText(gameState.confessionMeter)}ã€(å…§éƒ¨æ•¸å€¼: ${gameState.confessionMeter}%)ã€‚
            ä»–å‰›å‰›èªªäº† (æˆ–è¢«å•äº†): "${lastAIMessage || 'åµè¨Šå‰›é–‹å§‹'}"ã€‚
            è«‹ç”Ÿæˆä¸€å€‹åˆæ³•çš„JSONå°è±¡ï¼ŒåŒ…å«ä»¥ä¸‹å››å€‹éµå€¼å°ï¼Œæ¯å€‹å€¼éƒ½æ˜¯ä¸€æ®µç°¡çŸ­çš„æè¿° (æ¯é …ç´„5-10å­—):
            "facialExpression": (ä¾‹å¦‚ï¼š"å˜´è§’å¾®å¾®æŠ½å‹•", "çœ¼ç¥æœ‰äº›é£„å¿½ä¸å®š", "é¢ç„¡è¡¨æƒ…ä½†çœ‰é ­å¾®è¹™")
            "bodyLanguage": (ä¾‹å¦‚ï¼š"é›™æ‰‹ç·Šæ¡æ”¾åœ¨æ¡Œä¸Š", "åç«‹ä¸å®‰ï¼Œèº«é«”ç¨å¾®å¾Œä»°", "èº«é«”å¾®å¾®å‰å‚¾ï¼Œä¼¼ä¹æƒ³è§£é‡‹")
            "microAction": (ä¾‹å¦‚ï¼š"æ‰‹æŒ‡ä¸è‡ªè¦ºåœ°è¼•æ•²æ¡Œé¢", "ä¸‹æ„è­˜æ’¥å¼„è¡£è§’", "çŸ­æš«åœ°èˆ”äº†èˆ”å˜´å”‡")
            "voiceTone": (ä¾‹å¦‚ï¼š"èªæ°£å¹³æ·¡ï¼Œè½ä¸å‡ºæƒ…ç·’", "è²éŸ³ç•¥é¡¯æ²™å•", "è©¦åœ–ä¿æŒå¼·ç¡¬ä½†ç•¥å¸¶é¡«æŠ–")
            ç¢ºä¿è¼¸å‡ºç‚ºä¸€å€‹å–®ä¸€çš„ã€åˆæ³•çš„JSONå°è±¡ã€‚`;

            let rawResponse = await callDeepSeekAPI(systemPrompt, userPrompt, true); // true indicates expecting multiple fields (JSON)
            
            try {
                // Attempt to clean the rawResponse if it's a string and contains markdown
                if (typeof rawResponse === 'string') {
                    if (rawResponse.startsWith("```json")) {
                        rawResponse = rawResponse.substring(7); // Remove ```json
                        if (rawResponse.endsWith("```")) {
                            rawResponse = rawResponse.substring(0, rawResponse.length - 3); // Remove ```
                        }
                    }
                    rawResponse = rawResponse.trim(); // Trim any leading/trailing whitespace
                }

                if (rawResponse && typeof rawResponse === 'string' && !rawResponse.startsWith("AI (DeepSeek) ç„¡æ³•å›æ‡‰")) {
                    const parsed = JSON.parse(rawResponse);
                    // Basic validation if parsed is an object with expected keys
                    if (typeof parsed === 'object' && parsed !== null && 
                        'facialExpression' in parsed && 'bodyLanguage' in parsed &&
                        'microAction' in parsed && 'voiceTone' in parsed) {
                        return parsed;
                    } else {
                         console.warn("Parsed JSON for observable state is not in expected format:", parsed);
                         return { 
                            facialExpression: "ç¥æƒ…è¤‡é›œ", bodyLanguage: "å§¿æ…‹åƒµç¡¬", 
                            microAction: "å°å‹•ä½œé »é »", voiceTone: "èªæ°£ä¸å®š" 
                         };
                    }
                } else if (rawResponse && typeof rawResponse === 'object' && rawResponse.error) {
                    // Handle cases where callDeepSeekAPI itself returned an error object
                    console.error("DeepSeek API returned an error object for observable state:", rawResponse.error);
                }
            } catch (e) {
                console.error("Failed to parse observable state JSON from AI:", e, "Cleaned/Raw AI response:", rawResponse);
            }
            // Fallback for API error or parsing failure
            console.warn("Using fallback observable state due to API/parsing error.");
            return { 
                facialExpression: gameState.confessionMeter > 50 ? "é®å®šè‡ªè‹¥" : "ç•¥é¡¯ç·Šå¼µ",
                bodyLanguage: gameState.confessionMeter > 50 ? "å§¿æ…‹æ”¾é¬†" : "èº«é«”ç·Šç¹ƒ",
                microAction: gameState.confessionMeter > 50 ? "ç„¡æ˜é¡¯å°å‹•ä½œ" : "æ‰‹æŒ‡å¾®å¾®é¡«æŠ–",
                voiceTone: gameState.confessionMeter > 50 ? "èªæ°£å¹³ç©©" : "è²éŸ³ç•¥å¸¶ä¸ç©©"
            };
        }

        // Function to update suspect's physiological and observable state
        async function updateSuspectStatus(lastAIMessage = "") {
            // Simulate physiological changes (heart rate, blood pressure)
            let hrChange = Math.floor(Math.random() * 10) - 5; // Base change -5 to +4
            let bpSysChange = Math.floor(Math.random() * 10) - 5;
            let bpDiaChange = Math.floor(Math.random() * 6) - 3;

            if (gameState.confessionMeter < 50) { // More stressed if meter is low
                hrChange += Math.floor(Math.random() * (gameState.confessionMeter < 25 ? 10 : 5)) + (gameState.confessionMeter < 25 ? 3 : 2); // Increase more if very low
                bpSysChange += Math.floor(Math.random() * (gameState.confessionMeter < 25 ? 10 : 5)) + (gameState.confessionMeter < 25 ? 3 : 2);
            } else { // Less stressed if meter is high
                 hrChange -= Math.floor(Math.random() * 3); // Slight decrease tendency
                 bpSysChange -= Math.floor(Math.random() * 3);
            }
            gameState.suspect.heartRate = Math.max(60, Math.min(140, gameState.suspect.heartRate + hrChange)); // Clamp values
            let [sys, dia] = gameState.suspect.bloodPressure.split('/').map(Number);
            sys = Math.max(90, Math.min(190, sys + bpSysChange));
            dia = Math.max(60, Math.min(120, dia + bpDiaChange));
            gameState.suspect.bloodPressure = `${sys}/${dia}`;

            // Update observable state (facial expression, body language, etc.) using AI
            const newObservables = await generateSuspectObservableState(lastAIMessage);
            gameState.suspect.facialExpression = newObservables.facialExpression || gameState.suspect.facialExpression; // Use new or keep old if error
            gameState.suspect.bodyLanguage = newObservables.bodyLanguage || gameState.suspect.bodyLanguage;
            gameState.suspect.microAction = newObservables.microAction || gameState.suspect.microAction;
            gameState.suspect.voiceTone = newObservables.voiceTone || gameState.suspect.voiceTone;
        }


        // --- UI Update Functions ---
        function updateUI(state) {
            if (!state) return;
            roundCountEl.textContent = state.round;
            confessionMeterTextEl.textContent = getConfessionMeterText(state.confessionMeter); // Use text description

            // Update suspect status on main screen
            if (state.suspect) {
                heartRateEl.textContent = state.suspect.heartRate;
                bloodPressureEl.textContent = state.suspect.bloodPressure;
                facialExpressionEl.textContent = state.suspect.facialExpression;
                bodyLanguageEl.textContent = state.suspect.bodyLanguage;
                microActionEl.textContent = state.suspect.microAction;
                voiceToneEl.textContent = state.suspect.voiceTone;

                // Update personal details modal content
                suspectNameModalEl.textContent = state.suspect.name;
                dobModalEl.textContent = state.suspect.dob || "N/A";
                zodiacModalEl.textContent = state.suspect.zodiac || "N/A";
                bloodTypeModalEl.textContent = state.suspect.bloodType || "N/A";
                ageModalEl.textContent = state.suspect.age || "N/A";
                genderModalEl.textContent = state.suspect.gender || "N/A";
                personalityModalEl.textContent = state.suspect.personality || "è®€å–ä¸­...";
            }
            
            // Update story summary modal content
            if (state.caseDetails) {
                autopsyReportModalEl.innerHTML = state.caseDetails.autopsyReport.replace(/\n/g, "<br>"); // Handle newlines in autopsy
                evidenceListModalEl.innerHTML = state.caseDetails.evidence.map(e => `<li data-id="${e.id}">${e.text}</li>`).join('');
                doubtsListModalEl.innerHTML = state.caseDetails.doubts.map(d => `<li data-id="${d.id}">${d.text}</li>`).join('');
            }
            
            dialogueAreaEl.innerHTML = ''; 
            if (state.dialogueHistory) {
                state.dialogueHistory.forEach(msg => addMessageToDialogue(msg.speaker, msg.text));
            }

            // Re-attach keyword listeners for modals (evidence/doubts are now in modal)
            document.querySelectorAll('#evidence-list-modal .keyword, #doubts-list-modal .keyword').forEach(el => {
                el.onclick = () => {
                    const keyword = el.dataset.keyword;
                    keywordModalTitle.textContent = `ğŸ”‘ é—œæ–¼ã€Œ${keyword}ã€`;
                    getKeywordInfo(keyword);
                    keywordModal.classList.remove('hidden');
                };
            });

            if (state.gameOver) {
                gameOverTitle.textContent = state.confessionMeter <= 0 ? "âš–ï¸ å¯©å•æˆåŠŸï¼" : "âš–ï¸ å¯©å•å¤±æ•—ï¼";
                gameOverText.textContent = state.confessionMeter <= 0 ? `${state.suspect.name} å·²èªç½ªï¼` : `${state.suspect.name} å …ä¸èªç½ªï¼`;
                totalRoundsEl.textContent = state.round;
                gameOverModal.classList.remove('hidden');
            } else {
                gameOverModal.classList.add('hidden');
            }
        }

        function addMessageToDialogue(speaker, text) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('dialogue-bubble');
            if (speaker === 'Player') {
                messageDiv.classList.add('player-bubble');
            } else {
                messageDiv.classList.add('ai-bubble');
            }
            const processedText = text.replace(/@@(.*?)@@/g, '<span class="keyword" data-keyword="$1">$1</span>');
            messageDiv.innerHTML = processedText;
            dialogueAreaEl.appendChild(messageDiv);
            dialogueAreaEl.scrollTop = dialogueAreaEl.scrollHeight; 

            messageDiv.querySelectorAll('.keyword').forEach(el => {
                el.onclick = () => {
                    const keyword = el.dataset.keyword;
                    keywordModalTitle.textContent = `ğŸ”‘ é—œæ–¼ã€Œ${keyword}ã€`;
                    getKeywordInfo(keyword); 
                    keywordModal.classList.remove('hidden');
                };
            });
        }

        // --- Game Logic ---
        async function handlePlayerTurn() {
            const playerMessage = playerInputEl.value.trim();
            if (!playerMessage) return;

            sendButton.disabled = true;
            sendButton.innerHTML = '<div class="loading-spinner !w-5 !h-5 border-t-white"></div>';

            gameState.round++;
            addMessageToDialogue('Player', playerMessage);
            gameState.dialogueHistory.push({ speaker: 'Player', text: playerMessage });
            playerInputEl.value = '';

            const aiResponses = await getAIResponse(playerMessage);
            aiResponses.forEach(response => {
                addMessageToDialogue('AI', response);
                gameState.dialogueHistory.push({ speaker: 'AI', text: response });
            });
            
            // Decrease confession meter
            let decrease = 5 + Math.floor(Math.random() * 10); 
            if (gameState.selectedTone === "æŒ‘é‡" && Math.random() < 0.4) decrease += 5; 
            if (gameState.selectedTone === "æ†¤æ€’" && Math.random() < 0.2) decrease -= 3; // Anger can backfire
            if (playerMessage.length > 30 && Math.random() < 0.3) decrease +=3; // Slightly shorter length for mobile consideration
            gameState.confessionMeter = Math.max(0, gameState.confessionMeter - decrease);
            
            await updateSuspectStatus(aiResponses.join(" ")); // Update suspect's physiological and observable state

            if (gameState.confessionMeter <= 0) {
                gameState.gameOver = true;
                const confessionMsg = `${gameState.suspect.name}: ...å¥½å§ï¼Œæˆ‘æ‰¿èª...æ˜¯æˆ‘åšçš„ã€‚`;
                addMessageToDialogue('AI', confessionMsg);
                gameState.dialogueHistory.push({ speaker: 'AI', text: confessionMsg });
            }
            
            updateUI(gameState); // Crucial: update UI after all state changes
            await saveGameState();

            sendButton.disabled = false;
            sendButton.innerHTML = 'ç™¼é€';
        }

        function restartGame() {
            gameId = `game_${Date.now()}`; 
            // Preserve some generated details like DOB, name, gender, personality
            const oldSuspectBasicInfo = {
                name: gameState.suspect.name,
                dob: gameState.suspect.dob,
                zodiac: gameState.suspect.zodiac,
                bloodType: gameState.suspect.bloodType,
                age: gameState.suspect.age,
                gender: gameState.suspect.gender,
                personality: gameState.suspect.personality // Keep the generated personality
            };

            gameState = { 
                round: 0, confessionMeter: 100,
                suspect: { 
                    ...oldSuspectBasicInfo, // Use preserved basic info
                    // Reset dynamic states
                    heartRate: 75, bloodPressure: "120/80", 
                    facialExpression: "è®€å–ä¸­...", bodyLanguage: "è®€å–ä¸­...",
                    microAction: "è®€å–ä¸­...", voiceTone: "è®€å–ä¸­..."
                }, 
                caseDetails: { ...gameState.caseDetails }, // Case details are static for now
                dialogueHistory: [{ speaker: "AI", text: "ä½ å¥½ï¼Œè­¦å®˜ã€‚æœ‰ä»€éº¼äº‹å—ï¼Ÿ" }],
                selectedTone: "å¹³ç·©", gameOver: false
            };
            
            // Regenerate only the observable state, personality and basic details are kept
            generateSuspectObservableState("éŠæˆ²é‡æ–°é–‹å§‹ã€‚").then(initialObservables => {
                gameState.suspect.facialExpression = initialObservables.facialExpression || "é¢ç„¡è¡¨æƒ…";
                gameState.suspect.bodyLanguage = initialObservables.bodyLanguage || "é›™æ‰‹æ”¾åœ¨æ¡Œä¸Š";
                gameState.suspect.microAction = initialObservables.microAction || "å¶çˆ¾çœ¨çœ¼";
                gameState.suspect.voiceTone = initialObservables.voiceTone || "èªæ°£å¹³éœ";
                loadOrCreateGameState(); // This will effectively create/load the new game doc due to new gameId or reset existing
            });
            gameOverModal.classList.add('hidden');
        }

        // Event Listeners
        sendButton.addEventListener('click', handlePlayerTurn);
        playerInputEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); handlePlayerTurn();
            }
        });
        toneButtons.forEach(button => {
            button.addEventListener('click', () => {
                toneButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                gameState.selectedTone = button.dataset.tone;
            });
        });
        
        showPersonalDetailsButton.addEventListener('click', () => personalDetailsModal.classList.remove('hidden'));
        showStorySummaryButton.addEventListener('click', () => storySummaryModal.classList.remove('hidden'));
        
        restartGameButton.addEventListener('click', restartGame);

        // Initialize Game
        initializeGame();
    </script>
</body>
</html>
