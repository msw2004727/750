# app.py
import os
import json
import requests
import firebase_admin
from firebase_admin import credentials, firestore
from flask import Flask, request, jsonify
from flask_cors import CORS

# --- 初始化 Flask 應用 ---
app = Flask(__name__)
# 允許來自任何來源的跨域請求，這對於前後端分離的開發至關重要
CORS(app)

# --- 初始化 Firebase Admin SDK ---
try:
    # Render 會將 JSON 內容作為一個字串讀入環境變數
    firebase_creds_str = os.environ.get('FIREBASE_SERVICE_ACCOUNT_KEY')
    if not firebase_creds_str:
        raise ValueError("Firebase 服務帳號金鑰未在環境變數中設定！")

    # 將 JSON 字串解析為 Python 字典
    service_account_info = json.loads(firebase_creds_str)

    # 使用解析後的字典初始化憑證
    cred = credentials.Certificate(service_account_info)
    firebase_admin.initialize_app(cred, {
        'projectId': service_account_info.get('project_id'),
    })
    db = firestore.client()
    print("Firebase 初始化成功！")
except Exception as e:
    print(f"Firebase 初始化失敗: {e}")
    db = None

# --- AI API 設定 ---
DEEPSEEK_API_URL = "https://api.deepseek.com/chat/completions"

@app.route('/')
def index():
    return "文字江湖遊戲後端已啟動！"

@app.route('/api/generate_turn', methods=['POST'])
def generate_turn():
    """
    接收玩家行動，呼叫 AI 生成下一回合內容，並更新資料庫。
    """
    if not db:
        return jsonify({"error": "資料庫服務未初始化，無法處理請求。"}), 500

    try:
        # 1. 從前端請求中獲取玩家行動
        data = request.get_json()
        player_action = data.get('player_action')
        if not player_action:
            return jsonify({"error": "請求中未包含玩家行動 'player_action'"}), 400

        # (未來步驟) 2. 從 Firebase 讀取當前的遊戲世界狀態
        # game_state_ref = db.collection('games').document('game_session_main')
        # current_world_state = game_state_ref.get().to_dict()
        # if not current_world_state:
        #     # 如果沒有存檔，可以創建一個初始狀態
        #     current_world_state = {"story_log": "遊戲開始..."} # 範例

        # 3. 準備呼叫 DeepSeek AI
        api_key = os.environ.get('DEEPSEEK_API_KEY')
        if not api_key:
            return jsonify({"error": "DeepSeek API Key 未設定。"}), 500

        headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }

        # 建立一個強大的系統提示，指導 AI 的行為
        system_prompt = """
        你是文字RPG遊戲《文字江湖：黑風寨崛起》的遊戲管理員(Game Master)。
        你的職責是根據玩家的選擇，基於已有的世界觀、角色數據和劇情模組，生成下一回合的遊戲內容。
        你的回應必須嚴格遵守以下規則：
        1. 格式：完全遵循 '重要_📑 每回合格式排版規則 (standard_round_log_template.ml).ini' 檔案中定義的格式，包含所有必要的區塊。
        2. 世界觀：所有描述、用詞、單位和情節都必須符合 'AI GM 指令 - 核心世界觀設定.txt' 中的金庸武俠風格。
        3. 邏輯：所有事件的發生都必須符合遊戲的內部邏輯，不可憑空產生或違背物理常識。
        4. 數據驅動：NPC 的反應、技能的判定、資源的變化都應基於其背後的數據（雖然你不需要直接展示數值）。
        5. 劇情推進：根據玩家的行動，自然地推進劇情，並在回合結束時提供 3-5 個合乎情理的行動選項。
        """

        # (未來步驟) 這裡可以將 current_world_state 的摘要也加入到提示中
        # user_prompt = f"當前世界狀態摘要：{current_world_state['story_log'][-5:]}\n\n玩家選擇的行動是：'{player_action}'。\n\n請生成下一回合的完整內容。"

        # 目前簡化版的使用者提示
        user_prompt = f"玩家選擇的行動是：'{player_action['text']}' (ID: {player_action['id']})。\n\n請根據這個行動，生成下一回合的完整遊戲內容。"

        payload = {
            "model": "deepseek-chat",
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "stream": False # 確保一次性返回完整內容
        }

        # 4. 發送請求給 DeepSeek
        response = requests.post(DEEPSEEK_API_URL, headers=headers, json=payload)
        response.raise_for_status()  # 如果請求失敗 (e.g., 4xx, 5xx)，會拋出異常
        
        ai_response_data = response.json()
        next_turn_content = ai_response_data['choices'][0]['message']['content']

        # (未來步驟) 5. 解析 AI 回應，更新遊戲世界狀態並存回 Firebase
        # new_world_state = parse_ai_response_and_update_state(current_world_state, next_turn_content)
        # game_state_ref.set(new_world_state)

        # 6. 將 AI 生成的下一回合內容返回給前端
        return jsonify({"narrative": next_turn_content})

    except requests.exceptions.RequestException as e:
        return jsonify({"error": f"呼叫 AI 服務失敗: {e}"}), 503
    except Exception as e:
        print(f"伺服器內部錯誤: {e}")
        return jsonify({"error": "伺服器內部錯誤。"}), 500

if __name__ == '__main__':
    # 這允許我們在本地直接運行以進行測試
    # Render 會使用 Gunicorn 來啟動，而不是直接運行這個檔案
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 8080)))
